# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @describeIn build_U Build the U matrix (C++ implementation)
#' @templateVar n_vars TRUE
#' @templateVar n_lags TRUE
#' @template man_template
build_U_cpp <- function(Pi, n_determ, n_vars, n_lags) {
    .Call('MFBVAR_build_U_cpp', PACKAGE = 'MFBVAR', Pi, n_determ, n_vars, n_lags)
}

#' @title Find maximum eigenvalue
#'
#' @description The function computes the maximum eigenvalue.
#' @aliases max_eig max_eig_cpp
#' @templateVar A TRUE
#' @template man_template
#' @return The maximum eigenvalue.
max_eig_cpp <- function(A) {
    .Call('MFBVAR_max_eig_cpp', PACKAGE = 'MFBVAR', A)
}

#' @rdname dnorminvwish
rmatn <- function(M, Q, P) {
    .Call('MFBVAR_rmatn', PACKAGE = 'MFBVAR', M, Q, P)
}

#' @rdname dnorminvwish
rinvwish <- function(v, S) {
    .Call('MFBVAR_rinvwish', PACKAGE = 'MFBVAR', v, S)
}

#' @rdname dmultn
rmultn <- function(m, Sigma) {
    .Call('MFBVAR_rmultn', PACKAGE = 'MFBVAR', m, Sigma)
}

#' @title Smooth and sample from the smoothed distribution
#'
#' @description Functions for smoothing and sampling from the (smoothed) distribution \eqn{p(Z_{1:T}|Y_{1:T}, \Theta)}.
#' @details Implemented in C++.
#' @aliases smoother simulation_smoother generate_mhh loglike
#' @describeIn smoother Compute smoothed states
#' @templateVar mZ TRUE
#' @templateVar Lambda TRUE
#' @templateVar mF TRUE
#' @templateVar mQ TRUE
#' @templateVar iT TRUE
#' @templateVar ip TRUE
#' @templateVar iq TRUE
#' @templateVar h0 TRUE
#' @templateVar P0 TRUE
#' @template man_template
#' @return For \code{smoother}:
#' \item{}{The smoothed states.}
smoother <- function(mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0) {
    .Call('MFBVAR_smoother', PACKAGE = 'MFBVAR', mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0)
}

#' @describeIn smoother Generate pseudo-state vector
#' @return For \code{generate_mhh}:
#' \item{}{Generated (pseudo-)state vector.}
generate_mhh <- function(mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0) {
    .Call('MFBVAR_generate_mhh', PACKAGE = 'MFBVAR', mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0)
}

#' @describeIn smoother Simulation smoother
#' @return For \code{simulation_smoother}:
#' \item{}{The draw from the posterior distribution.}
simulation_smoother <- function(mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0) {
    .Call('MFBVAR_simulation_smoother', PACKAGE = 'MFBVAR', mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0)
}

#' @describeIn smoother Compute log-likelihood
#' @return For \code{loglike}:
#' \item{}{An \code{n_T}-long vector of the log-likelihoods. \code{exp(sum(loglike(...)))} is the likelihood.}
loglike <- function(mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0) {
    .Call('MFBVAR_loglike', PACKAGE = 'MFBVAR', mZ, Lambda, mF, mQ, iT, ip, iq, h0, P0)
}

