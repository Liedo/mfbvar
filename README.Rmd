---
output:
  github_document
---
# mfbvar
[![Travis-CI Build Status](https://travis-ci.org/ankargren/mfbvar.svg?branch=0.3.0.9000)](https://travis-ci.org/ankargren/mfbvar)

## Overview 
The `mfbvar` package implements a steady-state prior and a Minnesota prior for state space-based mixed-frequency VAR models. *Note that the examples require the development version 0.3.0.900 (available in its own branch) to work.*
<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
thm = knitr::knit_theme$get("edit-xcode")
knitr::knit_theme$set(thm)
```

First, obtain some data stored in the package.
```{r}
library(mfbvar)
Y <- mf_list$data[[192]]
head(Y)
tail(Y)
```
Next, we create a minimal prior object. We must specify: 1) data, 2) an aggregation matrix or a vector of strings with aggregation schemes, 3) the number of lags, 4) the length of burn-in and main chains, respectively. This is done by calling the `set_prior()` function and giving named arguments. The resulting object is of class `mfbvar_prior` and has a basic `print` method.
```{r}
prior_obj <- set_prior(Y = Y, Lambda = c(rep("identity", 4), "average", "identity"), 
                       n_lags = 4, n_burnin = 1000, n_reps = 1000)
```
Warnings are produced because we haven't specified values for some of the prior elements and instead the function uses default values.

There is a print method for the prior object, showing some basic information:
```{r]}
prior_obj
```
The message tells us what elements of the prior have not yet been set, and if each of the two priors can be run with the current specification. The check is very minimal; the steady-state prior cannot be used to make forecasts (which it will attempt to if `n_fcst` is greater than `0`) unless also `d_fcst` is given, but to run the model with no forecasts only the three indicated elements are missing.

The summary method provides a little bit more detail:
```{r}
summary(prior_obj)
```
As the print method told us before, we can run the Minnesota prior, but not the steady-state prior with the current prior specification. The model is run by calling `estimate_mfbvar()`.
```{r, cache = TRUE}
mod_minn <- estimate_mfbvar(mfbvar_prior = prior_obj, prior_type = "minn")
```
To use the steady-state prior, we need to specify `d`, `prior_psi_mean` and `prior_psi_Omega`. We specify the prior moments for $\psi$ using the helper function `interval_to_moments()` which converts 95 % prior probability intervals to prior moments, assuming independence.
```{r}
d <- matrix(1, nrow = nrow(Y), ncol = 1)
prior_intervals <- matrix(c( 6,   7,
                             0.1, 0.2,
                             0,   0.5,
                            -0.5, 0.5,
                             0.4, 0.6,
                            -0.5, 0.5), ncol = 2, byrow = TRUE)
psi_moments <- interval_to_moments(prior_intervals)
prior_psi_mean <- psi_moments$prior_psi_mean
prior_psi_Omega <- psi_moments$prior_psi_Omega

prior_obj <- update_prior(prior_obj, d = d, prior_psi_mean = prior_psi_mean, prior_psi_Omega = prior_psi_Omega)
prior_obj

```

It is now possible to run the model using the steady-state prior.

```{r, cache = TRUE}
mod_ss <- estimate_mfbvar(prior_obj, "ss")
```

It is also allowed to temporarily override elements in the prior object by adding them as separate arguments to the `estimate_mfbvar()` function. Thus, to get forecasts eight steps ahead we could do:
```{r, cache = TRUE}
mod_minn <- estimate_mfbvar(prior_obj, "minn", n_fcst = 8)
mod_ss <- estimate_mfbvar(prior_obj, "ss", n_fcst = 8, d_fcst = matrix(1, nrow = 8, ncol = 1))
```
The resulting objects contain all of the posterior information. For forecasts, there is a `predict` method which computes forecasts for selected quantiles. By default, it returns the 10%, 50% and 90% quantiles.

```{r}
predict(mod_minn, pred_quantiles = 0.5)
```
If desired, it can be requested in a tidy format.
```{r}
head(predict(mod_minn, pred_quantiles = 0.5, tidy = TRUE))
```
To estimate the marginal data density, there is a generic function `mdd()` for which there are methods for classes `mfbvar_ss` and `mfbvar_minn`.
```{r, cache = TRUE}
mdd(mod_minn, quarterly_cols = 5)
mdd(mod_ss) 
```
The caveat is that the mdd is estimated up to a constant and thus not directly comparable between models based on different prios.
